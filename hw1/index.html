<html>
	<head>
	</head>
	<body>
		<h1>Homework 1</h1>
		<h2>Problem 1</h2>
		<p>The main operation of rasterizing a triangle comes down to checking if a point lies within the triangle.
		In order to check this, I used the simple three-line equation from Lecture 2.</p>
		<p>To generate the triangle's bounding box, the function first finds the maximum and mimumum X and Y values 
		of the three input points. Then, it checks each of those points for interiority by running each through 
		the three-line equation. Therefore, it is exactly as efficient as one that checks every point within
		the bounding box.</p>
		<img src="./image1.png" alt="An image showing various colored triangles, with notable jaggies shown in the top-right.">
		<br/>
		<h2>Problem 2</h2>
		<p>To supersample, I use the same three-line test from Problem 1, but this time split each pixel at decimal increments.
		I updated the sample array to contain <code>sample_rate</code> times as many elements, with the element at 
		position <code>sample_rate * (y * width + x) + sub</code> corresponding to subsample number <code>sub</code> at a
		given pixel. Then, when rendering, I iterate through the sample buffer and average the subsamples to create each
		pixel.</p>
		<p>Subsampling is useful because it allows for non-binary detail, which reduces jaggies and therefore improves
		overall visual quality. The supersampling method I implemented allows for points near the edge of an object to
		express more detail, which comes across to the eye as almost "sub-pixel" quality without needing more pixels.</p>
		<p>This naturally required updating every change to and access of the sample buffer with this new subdivided
		coordinate system, including changes to <code>fill_pixel</code>, <code>rasterize_triangle</code>, 
		<code>set_sample_rate</code>, and <code>set_framebuffer_target</code>.</p>
		<p>The images below show the practical effect of supersampling on a sharp corner.</p>
		<p>A sampling rate of 1 below. Notice the serious jaggies on the green triangle's thin point. This occurs
		because the point defining the triangle's vertex is just short of touching the pixel, leaving the point
		in an unnatural shape.</p>
		<img src="./image21.png" alt="Sampling rate of 1.">
		<p>A sampling rate of 4 below. The point is better now, having a few lighter-colored pixels to
		make the transition from white to green less jarring, though the top of the triangle is still bumpy.</p>
		<img src="./image22.png" alt="Sampling rate of 4.">
		<p>A sampling rate of 16 below. The top is now very smooth, as is the point and bottom edge.</p>
		<img src="./image23.png" alt="Sampling rate of 16.">
		<br/>
		<h2>Problem 3</h2>
		<p>	
		I have my cubeman dressed up as a ninja doing a "crane" pose! Aside the posing, I added a red headband and a hole in the mask.
		</p>
		<img src="./image3.png" alt="Ninja cubeman">
		<br/>
		<h2>Problem 4</h2>
		<p>Barycentric coordinates work by setting each vertex to have a color, and then displaying a mixture of those colors
		when a location on the face is sampled. Specifically, the distance from the sampled point on the face to the vertex
		determines the effect of that vertex's color on the result color, with locations closer to a given vertex expressing that
		vertex's color more strongly.</p>
		<p>Consider the below image. The top-left point is set to red, the bottom to green, and the right to blue. In the middle,
		the triangle's display colors are defined by a mixture of the colors. This becomes gray in the center, as when R, G, and B
		are exactly equal, you create a shade of gray.</p>
		<image src="./image4.png" alt="An image showing barycentric coloring.">
		<br/>
		<h2>Problem 5</h2>
		<br/>
		<h2>Problem 6</h2>
	</body>
</html>
