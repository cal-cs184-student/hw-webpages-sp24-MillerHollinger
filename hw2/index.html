<html>
	<head>
		<style>
			p {
				background-color: lightgrey;
			}
		</style>
	</head>
	<body>
		<h1>Homework 2 @ <a href="https://cal-cs184-student.github.io/hw-webpages-sp24-MillerHollinger/hw2/index.html">https://cal-cs184-student.github.io/hw-webpages-sp24-MillerHollinger/hw2/index.html</a></h1>
		<h2>Overview</h2>
		<p>
			??? OVERVIEW GO HERE
		</p>
		<h2>Part 1</h2>
		<p>
			De Casteljau's Algorithm is a surprisingly elegant algorithm used to create Bezier curves out of a set of control points connected by lines. The basic idea is that you reduce the set of control points down
			to a set of intermediary points by connecting the midpoints of the lines between the control points. As there are X points and X-1 lines, you therefore end up with one fewer point in the
			intermediate set than you had in the control set. Repeating this process until only one point remains yields a point on the curve. To construct the whole curve, the midpoints are, instead of being precisely
			in the center, are instead weighted towards one end or the other of the curve using a value, called t. Drawing every resulting point with a t-value from 0 to 1 yields a Bezier curve.
		</p>
		<p>Starting with the curve shown below, we can show this process for the t-value 0.5.</p>
		<img src="./image11.png">
		<img src="./image12.png">
		<img src="./image13.png">
		<img src="./image14.png">
		<img src="./image15.png">
		<img src="./image16.png">
		<p>The red point is the final calculated point, and is on the bezier curve. Repeating this process for values of t between 0 and 1 yields the entire curve.</p>
		<p>See another example below with an altered t-value and control points.</p>
		<img src="./image17.png">
		<h2>Part 2</h2>
		<p>
			When extended to 3D, de Casteljau's algorithm works by essentially creating an intermediate set of control points. Each row of control points is treated as an individual Bezier curve,
			interpolated in three dimensions instead of two. The resulting point from that Bezier curve is then used as a control point, alongside the points created by each other row,
			to create a column-wise Bezier curve. That curve is also interpolated across to find the location of the final point.
		</p>
		<p>
			Another change when switching to 3D is that the "t" value is exchanged for two values, u and v. 
			These indicate the ratio of the linear interpolation for the rows and columns respectively. They are each varied between 0 and 1 independently.
			Having a separate u and v allows for a surface to be created instead of simply a line, as for each point defined by a given u value, a bezier curve can be created by varying the v value.
			The same is true in reverse -- therefore, a 2D bezier surface might be thought of as an infinite number of bezier curves pressed against each other.
		</p>
		<img src="./image2.png">
		<h2>Part 3</h2>
		<p>
			To implement the area-weighted vertex normals, I first created a loop that iterates through each halfedge leading into a point in a similar fashion to the provided printNeighborPositions() function. 
			At each step, two adjacent neighbors are found. By taking advantage of the half-edge system, these two neighbors are always the two neighbors which form a touching face.
			Then, the normal of this face is calculated using the cross product.
		</p>
		<p>
			At the end, each of these calculated normals is summed, then finally normalized to get the resulting normal of the vertex itself. The result is the ability to make very smooth-looking objects, like
			the one shown below.
		</p>
		<img src="./image31.png">
		<p>The teapot looks smooth despite the low-poly underlying geometry.</p>
		<img src="./image32.png">
		<h2>Part 4</h2>
		<p>
			With operations such as flipping an edge, all that is really necessary is a clear idea of what the object will look like before and after the operation. I used the guide provided to us
			at <a href="http://15462.courses.cs.cmu.edu/fall2015content/misc/HalfedgeEdgeOpImplementationGuide.pdf">http://15462.courses.cs.cmu.edu/fall2015content/misc/HalfedgeEdgeOpImplementationGuide.pdf</a>
			to get a visual understanding of what would change (and what would stay the same) after executing the edge flip operation.
		</p>
		<p>
			The main issue I had to debug revolved around the "outer neighbors," that is the outer half-edges, and ensuring their values were set properly. Debugging came down to simply going back
			over the code I wrote with a fine-toothed comb and verifying each element was correct as shown on the chart. After doing so, I found and fixed the error, though it was truly like finding
			a needle in a haystack.
		</p>
		<p>
			Here's some edge flipping action:
		</p>
		<img src="./image41.png">
		<p>After a few flips...</p>
		<img src="./image42.png">
		<p>And after many more flips.</p>
		<img src="./image43.png">
		<p>It makes an interesting pattern!</p>
		<img src="./image44.png">
	</body>
</html>
